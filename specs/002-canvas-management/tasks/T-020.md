# specs/002-canvas-management/tasks/T-020.md

## Task: Database Migrations

## Type
implementation

## Context
- **Phase**: Phase 3 - Data Layer
- **Builds on**: T-003 (SQLAlchemy models)
- **Blocks**: All service and API tasks

## Predecessors

### Cross-Feature
| Feature | File | Task | Import Statement |
|---------|------|------|------------------|
| 001-core-models | alembic/versions/001_users_table.py | 001-auth/T-012 | References users table for foreign keys |

### Within Feature
| Task | File | What This Task Imports |
|------|------|------------------------|
| T-003 | backend/canvas/models/*.py | Model definitions for migration schema |

## Scope
- **CREATE**: `alembic/versions/002_canvas_tables.py`

## Contract
```python
"""Canvas management tables

Revision ID: 002_canvas_tables
Revises: 001_users_table
Create Date: 2026-02-13 14:00:00.000000

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers
revision = '002_canvas_tables'
down_revision = '001_users_table'
branch_labels = None
depends_on = None

def upgrade() -> None:
    # Create lifecycle_lane enum
    lifecycle_lane_enum = postgresql.ENUM('build', 'sell', 'milk', 'reframe', name='lifecycle_lane')
    lifecycle_lane_enum.create(op.get_bind())
    
    # Create currently_testing_type enum
    currently_testing_type_enum = postgresql.ENUM('thesis', 'proof_point', name='currently_testing_type')
    currently_testing_type_enum.create(op.get_bind())
    
    # Create proof_point_status enum
    proof_point_status_enum = postgresql.ENUM('not_started', 'in_progress', 'observed', 'stalled', name='proof_point_status')
    proof_point_status_enum.create(op.get_bind())
    
    # Create vbus table
    op.create_table('vbus',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=sa.text('gen_random_uuid()')),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('gm_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False),
        sa.Column('updated_by', postgresql.UUID(as_uuid=True), nullable=True),
        sa.ForeignKeyConstraint(['gm_id'], ['users.id'], ondelete='RESTRICT'),
        sa.ForeignKeyConstraint(['updated_by'], ['users.id'], ondelete='SET NULL'),
        sa.CheckConstraint("LENGTH(TRIM(name)) > 0", name='ck_vbus_name_not_empty')
    )
    
    # Create canvases table
    op.create_table('canvases',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=sa.text('gen_random_uuid()')),
        sa.Column('vbu_id', postgresql.UUID(as_uuid=True), nullable=False, unique=True),
        sa.Column('product_name', sa.String(255), nullable=True),
        sa.Column('lifecycle_lane', lifecycle_lane_enum, nullable=False),
        sa.Column('success_description', sa.Text, nullable=True),
        sa.Column('future_state_intent', sa.Text, nullable=True),
        sa.Column('primary_focus', sa.String(255), nullable=True),
        sa.Column('resist_doing', sa.Text, nullable=True),
        sa.Column('good_discipline', sa.Text, nullable=True),
        sa.Column('primary_constraint', sa.Text, nullable=True),
        sa.Column('currently_testing_type', currently_testing_type_enum, nullable=True),
        sa.Column('currently_testing_id', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('portfolio_notes', sa.Text, nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False),
        sa.Column('updated_by', postgresql.UUID(as_uuid=True), nullable=True),
        sa.ForeignKeyConstraint(['vbu_id'], ['vbus.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['updated_by'], ['users.id'], ondelete='SET NULL'),
        sa.CheckConstraint("product_name IS NULL OR LENGTH(TRIM(product_name)) > 0", name='ck_canvas_product_name'),
        sa.CheckConstraint("(currently_testing_type IS NULL) = (currently_testing_id IS NULL)", name='ck_currently_testing_consistency')
    )
    
    # Create theses table
    op.create_table('theses',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=sa.text('gen_random_uuid()')),
        sa.Column('canvas_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('order', sa.Integer, nullable=False),
        sa.Column('text', sa.Text, nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False),
        sa.ForeignKeyConstraint(['canvas_id'], ['canvases.id'], ondelete='CASCADE'),
        sa.CheckConstraint("order BETWEEN 1 AND 5", name='ck_thesis_order_range'),
        sa.CheckConstraint("LENGTH(TRIM(text)) > 0", name='ck_thesis_text_not_empty'),
        sa.UniqueConstraint('canvas_id', 'order', name='uq_theses_canvas_order')
    )
    
    # Create proof_points table
    op.create_table('proof_points',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=sa.text('gen_random_uuid()')),
        sa.Column('thesis_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('description', sa.Text, nullable=False),
        sa.Column('status', proof_point_status_enum, nullable=False, default='not_started'),
        sa.Column('evidence_note', sa.Text, nullable=True),
        sa.Column('target_review_month', sa.Date, nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False),
        sa.ForeignKeyConstraint(['thesis_id'], ['theses.id'], ondelete='CASCADE'),
        sa.CheckConstraint("LENGTH(TRIM(description)) > 0", name='ck_proof_point_description_not_empty')
    )
    
    # Create attachments table
    op.create_table('attachments',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=sa.text('gen_random_uuid()')),
        sa.Column('proof_point_id', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('monthly_review_id', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('filename', sa.String(255), nullable=False),
        sa.Column('storage_path', sa.String(1024), nullable=False, unique=True),
        sa.Column('content_type', sa.String(128), nullable=False),
        sa.Column('size_bytes', sa.Integer, nullable=False),
        sa.Column('label', sa.String(255), nullable=True),
        sa.Column('uploaded_by', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False),
        sa.ForeignKeyConstraint(['proof_point_id'], ['proof_points.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['uploaded_by'], ['users.id'], ondelete='RESTRICT'),
        sa.CheckConstraint("LENGTH(TRIM(filename)) > 0", name='ck_attachment_filename_not_empty'),
        sa.CheckConstraint("LENGTH(TRIM(storage_path)) > 0", name='ck_attachment_storage_path_not_empty'),
        sa.CheckConstraint("size_bytes BETWEEN 1 AND 10485760", name='ck_attachment_size_range'),
        sa.CheckConstraint("label IS NULL OR LENGTH(TRIM(label)) > 0", name='ck_attachment_label'),
        sa.CheckConstraint("content_type IN ('image/png','image/jpeg','image/gif','application/pdf','text/csv','application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')", name='ck_attachment_content_type'),
        sa.CheckConstraint("(proof_point_id IS NOT NULL AND monthly_review_id IS NULL) OR (proof_point_id IS NULL AND monthly_review_id IS NOT NULL)", name='ck_attachment_single_parent')
    )
    
    # Create indexes
    op.create_index('ix_vbus_gm_id', 'vbus', ['gm_id'])
    op.create_index('uq_canvases_vbu_id', 'canvases', ['vbu_id'], unique=True)
    op.create_index('ix_canvases_lifecycle_lane', 'canvases', ['lifecycle_lane'])
    op.create_index('ix_theses_canvas_id', 'theses', ['canvas_id'])
    op.create_index('ix_proof_points_thesis_id', 'proof_points', ['thesis_id'])
    op.create_index('ix_proof_points_status', 'proof_points', ['status'])
    op.create_index('ix_attachments_proof_point_id', 'attachments', ['proof_point_id'])
    op.create_index('ix_attachments_uploaded_by', 'attachments', ['uploaded_by'])
    op.create_index('uq_attachments_storage_path', 'attachments', ['storage_path'], unique=True)

def downgrade() -> None:
    # Drop indexes
    op.drop_index('uq_attachments_storage_path', 'attachments')
    op.drop_index('ix_attachments_uploaded_by', 'attachments')
    op.drop_index('ix_attachments_proof_point_id', 'attachments')
    op.drop_index('ix_proof_points_status', 'proof_points')
    op.drop_index('ix_proof_points_thesis_id', 'proof_points')
    op.drop_index('ix_theses_canvas_id', 'theses')
    op.drop_index('ix_canvases_lifecycle_lane', 'canvases')
    op.drop_index('uq_canvases_vbu_id', 'canvases')
    op.drop_index('ix_vbus_gm_id', 'vbus')
    
    # Drop tables
    op.drop_table('attachments')
    op.drop_table('proof_points')
    op.drop_table('theses')
    op.drop_table('canvases')
    op.drop_table('vbus')
    
    # Drop enums
    op.execute('DROP TYPE proof_point_status')
    op.execute('DROP TYPE currently_testing_type')
    op.execute('DROP TYPE lifecycle_lane')
```

## Logic
1. Create PostgreSQL enums for lifecycle_lane, currently_testing_type, proof_point_status
2. Create vbus table with foreign key to users
3. Create canvases table with 1:1 relationship to vbus
4. Create theses table with ordering constraints
5. Create proof_points table with status enum
6. Create attachments table with polymorphic relationships
7. Add all indexes for performance
8. Add check constraints for data validation
9. Implement proper downgrade to reverse all changes

## Verification
- [ ] Migration runs without errors
- [ ] All tables created with correct schema
- [ ] Foreign key constraints properly defined
- [ ] Check constraints enforce data rules
- [ ] Indexes created for performance

## LOC Estimate
~120 lines