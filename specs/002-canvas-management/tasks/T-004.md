# specs/002-canvas-management/tasks/T-004.md

## Task: Pydantic Schemas

## Type
implementation

## Context
- **Phase**: Phase 1 - Contracts & Interfaces
- **Builds on**: T-003 (SQLAlchemy models)
- **Blocks**: T-014, T-015, T-016, T-017, T-018 (API endpoints)
- **Requirements**: FR-001, FR-002, FR-003, FR-004, FR-005, FR-006

## Predecessors

### Cross-Feature
| Feature | File | Task | Import Statement |
|---------|------|------|------------------|
| 001A-infrastructure | backend/canvas/models/__init__.py | 001A-infrastructure/T-006 | `from canvas.models import TimestampMixin` |

### Within Feature
| Task | File | What This Task Imports |
|------|------|------------------------|
| T-003 | backend/canvas/models/*.py | Enum types: LifecycleLane, CurrentlyTestingType, ProofPointStatus |

## Scope
- **CREATE**: `backend/canvas/schemas.py`

## Contract
```python
from datetime import date, datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field

# Enums
class LifecycleLane(str, Enum):
    BUILD = "build"
    SELL = "sell"
    MILK = "milk"
    REFRAME = "reframe"

class CurrentlyTestingType(str, Enum):
    THESIS = "thesis"
    PROOF_POINT = "proof_point"

class ProofPointStatus(str, Enum):
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    OBSERVED = "observed"
    STALLED = "stalled"

# Request Schemas
class VBUCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    gm_id: UUID

class VBUUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    gm_id: Optional[UUID] = None

class CanvasUpdate(BaseModel):
    product_name: Optional[str] = Field(None, max_length=255)
    lifecycle_lane: Optional[LifecycleLane] = None
    success_description: Optional[str] = None
    future_state_intent: Optional[str] = None
    primary_focus: Optional[str] = Field(None, max_length=255)
    resist_doing: Optional[str] = None
    good_discipline: Optional[str] = None
    primary_constraint: Optional[str] = None
    currently_testing_type: Optional[CurrentlyTestingType] = None
    currently_testing_id: Optional[UUID] = None
    portfolio_notes: Optional[str] = None

class ThesisCreate(BaseModel):
    text: str = Field(..., min_length=1)
    order: int = Field(..., ge=1, le=5)

class ThesisUpdate(BaseModel):
    text: Optional[str] = Field(None, min_length=1)

class ProofPointCreate(BaseModel):
    description: str = Field(..., min_length=1)
    status: ProofPointStatus = ProofPointStatus.NOT_STARTED
    evidence_note: Optional[str] = None
    target_review_month: Optional[date] = None

class ProofPointUpdate(BaseModel):
    description: Optional[str] = Field(None, min_length=1)
    status: Optional[ProofPointStatus] = None
    evidence_note: Optional[str] = None
    target_review_month: Optional[date] = None

# Response Schemas
class AttachmentResponse(BaseModel):
    id: UUID
    filename: str
    content_type: str
    size_bytes: int
    label: Optional[str]
    uploaded_by: UUID
    created_at: datetime

class ProofPointResponse(BaseModel):
    id: UUID
    description: str
    status: ProofPointStatus
    evidence_note: Optional[str]
    target_review_month: Optional[date]
    attachments: List[AttachmentResponse]
    created_at: datetime
    updated_at: datetime

class ThesisResponse(BaseModel):
    id: UUID
    order: int
    text: str
    proof_points: List[ProofPointResponse]
    created_at: datetime
    updated_at: datetime

class CanvasResponse(BaseModel):
    id: UUID
    vbu_id: UUID
    product_name: Optional[str]
    lifecycle_lane: LifecycleLane
    success_description: Optional[str]
    future_state_intent: Optional[str]
    primary_focus: Optional[str]
    resist_doing: Optional[str]
    good_discipline: Optional[str]
    primary_constraint: Optional[str]
    currently_testing_type: Optional[CurrentlyTestingType]
    currently_testing_id: Optional[UUID]
    portfolio_notes: Optional[str]
    created_at: datetime
    updated_at: datetime
    updated_by: Optional[UUID]

class VBUResponse(BaseModel):
    id: UUID
    name: str
    gm_id: UUID
    gm_name: str
    created_at: datetime
    updated_at: datetime
    updated_by: Optional[UUID]
```

## Logic
1. Import Pydantic BaseModel, Field, and validation types
2. Import enum types from models
3. Define request schemas with validation constraints
4. Define response schemas matching model structure
5. Apply field validation rules from schema.md

## Verification
- [ ] All imports resolve without error
- [ ] Enum values match model definitions
- [ ] Field constraints match database schema
- [ ] Response schemas include all required fields

## LOC Estimate
~120 lines