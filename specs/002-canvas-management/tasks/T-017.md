# specs/002-canvas-management/tasks/T-017.md

## Task: ProofPoint API Endpoints

## Type
implementation

## Context
- **Phase**: Phase 5 - API Layer
- **Builds on**: T-010 (ProofPoint Service Unit Tests), T-012 (CanvasService Implementation)
- **Blocks**: T-019 (CLI commands)

## Predecessors

### Cross-Feature
| Feature | File | Task | Import Statement |
|---------|------|------|------------------|
| 001-auth | backend/canvas/auth/dependencies.py | 001-auth/T-015 | `from canvas.auth.dependencies import get_current_user, require_role` |

### Within Feature
| Task | File | What This Task Imports |
|------|------|------------------------|
| T-012 | backend/canvas/services/canvas_service.py | CanvasService class |

## Scope
- **CREATE**: `backend/canvas/routes/proof_point.py`

## Contract
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List
from uuid import UUID

from canvas.auth.dependencies import get_current_user, require_role
from canvas.db import get_db_session
from canvas.services.canvas_service import CanvasService
from canvas.schemas.proof_point import ProofPointCreate, ProofPointUpdate, ProofPointResponse
from canvas.models.user import User
from canvas import success_response, list_response

router = APIRouter(prefix="/api", tags=["proof_point"])

@router.get("/theses/{thesis_id}/proof-points")
async def list_proof_points(
    thesis_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db_session)
) -> dict:
    """List proof points with attachments for a thesis."""
    ...

@router.post("/theses/{thesis_id}/proof-points")
async def create_proof_point(
    thesis_id: UUID,
    proof_point_data: ProofPointCreate,
    current_user: User = Depends(require_role(["admin", "gm"])),
    db: AsyncSession = Depends(get_db_session)
) -> dict:
    """Create new proof point for thesis."""
    ...

@router.patch("/proof-points/{proof_point_id}")
async def update_proof_point(
    proof_point_id: UUID,
    proof_point_data: ProofPointUpdate,
    current_user: User = Depends(require_role(["admin", "gm"])),
    db: AsyncSession = Depends(get_db_session)
) -> dict:
    """Update proof point status, description, evidence."""
    ...

@router.delete("/proof-points/{proof_point_id}")
async def delete_proof_point(
    proof_point_id: UUID,
    current_user: User = Depends(require_role(["admin", "gm"])),
    db: AsyncSession = Depends(get_db_session)
) -> dict:
    """Delete proof point (cascade to attachments)."""
    ...
```

## Logic
1. Import CanvasService from T-012
2. Import auth dependencies from 001-auth
3. Import response helpers from canvas.__init__
4. Define router with /api prefix
5. Implement list_proof_points - get thesis, check canvas ownership, return proof points with attachments
6. Implement create_proof_point - validate thesis ownership via canvas, create proof point, return response
7. Implement update_proof_point - validate ownership, update fields, return response
8. Implement delete_proof_point - validate ownership, cascade delete, return success

## Verification
- [ ] All endpoints require proper authentication
- [ ] GM users can only access proof points from their own VBU's canvases
- [ ] Admin users can access all proof points
- [ ] Status updates trigger dashboard health aggregation
- [ ] Cascade deletes work for proof point â†’ attachments
- [ ] Response envelopes follow standard format

## LOC Estimate
~100 lines