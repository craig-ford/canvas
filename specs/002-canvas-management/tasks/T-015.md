# specs/002-canvas-management/tasks/T-015.md

## Task: Canvas API Routes

## Type
implementation

## Context
- **Phase**: API Layer Implementation
- **Builds on**: T-008 (Canvas API Integration Tests)
- **Blocks**: T-022 (VBU Canvas Page)
- **Requirements**: FR-002, FR-006, FR-008

## Predecessors

### Cross-Feature
| Feature | File | Task | Import Statement |
|---------|------|------|------------------|
| 001-auth | backend/canvas/auth/dependencies.py | T-004 | `from canvas.auth.dependencies import get_current_user, require_role` |
| 001A-infrastructure | backend/canvas/__init__.py | T-006 | `from canvas import success_response, list_response` |

### Within Feature
| Task | File | What This Task Imports |
|------|------|------------------------|
| T-012 | backend/canvas/services/canvas_service.py | CanvasService methods |

## Scope
- **CREATE**: `backend/canvas/routes/canvas.py`

## Contract
```python
from typing import Dict, Any
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from canvas.db import get_db_session
from canvas.auth.dependencies import get_current_user
from canvas.models.user import User, UserRole
from canvas.models.vbu import VBU
from canvas.services.canvas_service import CanvasService
from canvas.schemas import CanvasUpdate, CanvasResponse, ThesisResponse, ProofPointResponse
from canvas import success_response

router = APIRouter(prefix="/api/vbus", tags=["canvas"])

@router.get("/{vbu_id}/canvas", response_model=dict)
async def get_canvas(
    vbu_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db_session)
):
    """Get canvas with nested theses and proof points"""
    # Check VBU exists and authorization
    result = await db.execute(select(VBU).where(VBU.id == vbu_id))
    vbu = result.scalar_one_or_none()
    if not vbu:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="VBU not found")
    
    # Check GM ownership
    if current_user.role == UserRole.GM and vbu.gm_id != current_user.id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    service = CanvasService()
    canvas = await service.get_canvas_by_vbu(vbu_id, db)
    
    # Build nested response with theses and proof points
    theses_data = []
    for thesis in sorted(canvas.theses, key=lambda t: t.order):
        proof_points_data = [
            ProofPointResponse(
                id=pp.id,
                description=pp.description,
                status=pp.status,
                evidence_note=pp.evidence_note,
                target_review_month=pp.target_review_month,
                attachments=[],  # Attachments loaded separately
                created_at=pp.created_at,
                updated_at=pp.updated_at
            ) for pp in pp.proof_points
        ]
        
        theses_data.append(ThesisResponse(
            id=thesis.id,
            order=thesis.order,
            text=thesis.text,
            proof_points=proof_points_data,
            created_at=thesis.created_at,
            updated_at=thesis.updated_at
        ))
    
    # Filter portfolio_notes for non-admin users
    portfolio_notes = canvas.portfolio_notes if current_user.role == UserRole.ADMIN else None
    
    canvas_response = CanvasResponse(
        id=canvas.id,
        vbu_id=canvas.vbu_id,
        product_name=canvas.product_name,
        lifecycle_lane=canvas.lifecycle_lane,
        success_description=canvas.success_description,
        future_state_intent=canvas.future_state_intent,
        primary_focus=canvas.primary_focus,
        resist_doing=canvas.resist_doing,
        good_discipline=canvas.good_discipline,
        primary_constraint=canvas.primary_constraint,
        currently_testing_type=canvas.currently_testing_type,
        currently_testing_id=canvas.currently_testing_id,
        portfolio_notes=portfolio_notes,
        theses=theses_data,
        created_at=canvas.created_at,
        updated_at=canvas.updated_at,
        updated_by=canvas.updated_by
    )
    
    return success_response(canvas_response)

@router.put("/{vbu_id}/canvas", response_model=dict)
async def update_canvas(
    vbu_id: UUID,
    canvas_data: CanvasUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db_session)
):
    """Update canvas fields"""
    # Check VBU exists and authorization
    result = await db.execute(select(VBU).where(VBU.id == vbu_id))
    vbu = result.scalar_one_or_none()
    if not vbu:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="VBU not found")
    
    # Check authorization for updates
    if current_user.role == UserRole.GM and vbu.gm_id != current_user.id:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    if current_user.role == UserRole.VIEWER:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    # Filter update data based on role
    update_data = canvas_data.dict(exclude_unset=True)
    
    # Remove portfolio_notes for non-admin users
    if current_user.role != UserRole.ADMIN and "portfolio_notes" in update_data:
        del update_data["portfolio_notes"]
    
    service = CanvasService()
    updated_canvas = await service.update_canvas(
        vbu_id=vbu_id,
        canvas_data=update_data,
        updated_by=current_user.id,
        db=db
    )
    
    # Build response (without nested data for update)
    portfolio_notes = updated_canvas.portfolio_notes if current_user.role == UserRole.ADMIN else None
    
    canvas_response = CanvasResponse(
        id=updated_canvas.id,
        vbu_id=updated_canvas.vbu_id,
        product_name=updated_canvas.product_name,
        lifecycle_lane=updated_canvas.lifecycle_lane,
        success_description=updated_canvas.success_description,
        future_state_intent=updated_canvas.future_state_intent,
        primary_focus=updated_canvas.primary_focus,
        resist_doing=updated_canvas.resist_doing,
        good_discipline=updated_canvas.good_discipline,
        primary_constraint=updated_canvas.primary_constraint,
        currently_testing_type=updated_canvas.currently_testing_type,
        currently_testing_id=updated_canvas.currently_testing_id,
        portfolio_notes=portfolio_notes,
        theses=[],  # Empty for update response
        created_at=updated_canvas.created_at,
        updated_at=updated_canvas.updated_at,
        updated_by=updated_canvas.updated_by
    )
    
    return success_response(canvas_response)
```

## Logic
1. Import CanvasService from T-012, auth dependencies, and response helpers
2. Implement GET /api/vbus/{vbu_id}/canvas with nested data loading
3. Implement PUT /api/vbus/{vbu_id}/canvas with role-based field filtering
4. Check VBU existence and GM ownership for both endpoints
5. Filter portfolio_notes field based on user role (admin-only)
6. Build nested response with theses and proof points for GET endpoint
7. Use CanvasService methods for all business logic operations
8. Apply proper authorization checks before service calls
9. Return standardized response envelopes with CanvasResponse schema

## Verification
- [ ] Both canvas endpoints implemented with proper HTTP methods
- [ ] VBU existence and ownership checks applied
- [ ] Nested data loading for GET endpoint includes theses and proof points
- [ ] Portfolio notes field filtered by user role
- [ ] Role-based authorization enforced for updates
- [ ] Standard response envelopes used throughout
- [ ] CanvasService methods used for business logic

## LOC Estimate
~110 lines