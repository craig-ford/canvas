# specs/001-auth/tasks/T-013.md

## Task: AuthService Implementation

## Type
implementation

## Context
- **Phase**: Phase 4 - Core Logic
- **Builds on**: T-009 (AuthService Unit Tests)
- **Blocks**: T-015 (Auth Dependencies Implementation), T-016 (Auth Routes Implementation)

## Predecessors

### Cross-Feature
| Feature | File | Task | Import Statement |
|---------|------|------|------------------|

### Within Feature
| Task | File | What This Task Imports |
|------|------|------------------------|
| T-009 | tests/test_auth_service_unit.py | Test specifications for AuthService methods |

## Scope
- **MODIFY**: `backend/canvas/auth/service.py`

## Contract
```python
from datetime import datetime, timedelta, timezone
from typing import Optional
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from passlib.context import CryptContext
from jose import JWTError, jwt
from canvas.models.user import User, UserRole
from canvas.config import settings

class AuthService:
    def __init__(self):
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto", bcrypt__rounds=12)
        self.secret_key = settings.SECRET_KEY
        self.algorithm = "HS256"
        self.access_token_expire_minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES
        self.refresh_token_expire_days = settings.REFRESH_TOKEN_EXPIRE_DAYS
    
    async def authenticate_user(self, email: str, password: str, db: AsyncSession) -> Optional[User]:
        """Authenticate user with email and password."""
        ...
    
    async def create_access_token(self, user: User) -> str:
        """Create JWT access token with 30min expiry."""
        ...
    
    async def create_refresh_token(self, user: User) -> str:
        """Create JWT refresh token with 7 day expiry."""
        ...
    
    async def verify_token(self, token: str) -> Optional[dict]:
        """Verify JWT token and return payload."""
        ...
    
    def _hash_password(self, password: str) -> str:
        """Hash password using bcrypt with cost factor 12."""
        ...
    
    def _verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """Verify password against bcrypt hash."""
        ...
    
    async def get_user_by_id(self, user_id: UUID, db: AsyncSession) -> Optional[User]:
        """Get user by ID."""
        ...
    
    async def increment_failed_attempts(self, email: str, db: AsyncSession) -> None:
        """Increment failed login attempts for user."""
        ...
    
    async def reset_failed_attempts(self, user: User, db: AsyncSession) -> None:
        """Reset failed login attempts on successful login."""
        ...
    
    def is_account_locked(self, user: User) -> bool:
        """Check if account is locked due to failed attempts."""
        ...
```

## Logic
1. Initialize CryptContext with bcrypt rounds=12
2. Implement authenticate_user: query by email, verify password, check lock status
3. Implement create_access_token: JWT with user_id, role, 30min expiry
4. Implement create_refresh_token: JWT with user_id, 7 day expiry
5. Implement verify_token: decode JWT, handle expiry/invalid signature
6. Implement password hashing/verification with bcrypt
7. Implement user lookup by ID with async session
8. Implement failed attempt tracking and account locking (5 attempts, 15min lock)
9. Use settings from config for JWT secret and expiry times

## Verification
- [ ] All methods implemented with real logic (no pass statements)
- [ ] bcrypt cost factor 12 configured correctly
- [ ] JWT tokens include correct claims and expiry
- [ ] Account locking after 5 failed attempts for 15 minutes
- [ ] Password verification uses constant-time comparison
- [ ] Database queries use async session properly
- [ ] Error handling for JWT decode failures

## LOC Estimate
~150 lines