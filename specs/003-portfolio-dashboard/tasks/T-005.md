# specs/003-portfolio-dashboard/tasks/T-005.md

## Task: Portfolio Service Implementation

## Type
implementation

## Context
- **Phase**: Phase 4 - Core Logic
- **Builds on**: T-001, T-004
- **Blocks**: T-007

## Predecessors

### Cross-Feature
| Feature | File | Task | Import Statement |
|---------|------|------|------------------|
| 001-auth | backend/canvas/models/user.py | 001-auth/T-011 | `from canvas.models.user import User` |
| 002-canvas-management | backend/canvas/models/vbu.py | 002-canvas-management/T-003 | `from canvas.models.vbu import VBU` |
| 002-canvas-management | backend/canvas/models/canvas.py | 002-canvas-management/T-003 | `from canvas.models.canvas import Canvas` |

### Within Feature
| Task | File | What This Task Imports |
|------|------|------------------------|
| T-001 | backend/canvas/portfolio/schemas.py | VBUSummary, PortfolioFilters |
| T-004 | backend/canvas/models/canvas.py | Canvas model with health_indicator_cache |

## Scope
- **MODIFY**: `backend/canvas/portfolio/service.py`
- **CREATE**: `tests/test_portfolio_service_impl.py`

## Contract
```python
# backend/canvas/portfolio/service.py implementation
from typing import List
import html
from fastapi import HTTPException
from sqlalchemy import text, update, func
from sqlalchemy.ext.asyncio import AsyncSession
from canvas.models.user import User
from canvas.models.canvas import Canvas
from canvas.db import get_db
from .schemas import VBUSummary, PortfolioFilters

class PortfolioService:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_summary(self, user: User, filters: PortfolioFilters) -> List[VBUSummary]:
        """Get portfolio summary with role-based filtering and health computation"""
        where_conditions = ["1=1"]
        params = {}
        
        # Role-based filtering
        if user.role == "gm":
            where_conditions.append("v.gm_id = :user_id")
            params["user_id"] = user.id
        
        # Lane filtering
        if filters.lane:
            where_conditions.append("c.lifecycle_lane = ANY(:lanes)")
            params["lanes"] = [lane.value for lane in filters.lane]
        
        # GM filtering
        if filters.gm_id:
            where_conditions.append("v.gm_id = ANY(:gm_ids)")
            params["gm_ids"] = filters.gm_id
        
        # Health status filtering
        if filters.health_status:
            where_conditions.append("COALESCE(c.health_indicator_cache, 'Not Started') = ANY(:health_statuses)")
            params["health_statuses"] = filters.health_status
        
        query = f"""
        SELECT v.id, v.name, u.name as gm_name, c.lifecycle_lane,
               c.success_description, c.primary_constraint, c.portfolio_notes,
               COALESCE(c.health_indicator_cache, 'Not Started') as health_indicator,
               CASE 
                   WHEN c.currently_testing_type = 'thesis' THEN 
                       (SELECT t.text FROM theses t WHERE t.id = c.currently_testing_id)
                   WHEN c.currently_testing_type = 'proof_point' THEN
                       (SELECT pp.description FROM proof_points pp WHERE pp.id = c.currently_testing_id)
                   ELSE NULL
               END as currently_testing,
               (SELECT MIN(mr.review_date + INTERVAL '1 month') 
                FROM monthly_reviews mr WHERE mr.canvas_id = c.id) as next_review_date
        FROM vbus v
        JOIN users u ON v.gm_id = u.id  
        JOIN canvases c ON c.vbu_id = v.id
        WHERE {' AND '.join(where_conditions)}
        ORDER BY v.name
        """
        
        result = await self.db.execute(text(query), params)
        return [VBUSummary(
            id=row.id,
            name=row.name,
            gm_name=row.gm_name,
            lifecycle_lane=row.lifecycle_lane,
            success_description=row.success_description,
            currently_testing=row.currently_testing,
            next_review_date=row.next_review_date,
            primary_constraint=row.primary_constraint,
            health_indicator=row.health_indicator,
            portfolio_notes=row.portfolio_notes
        ) for row in result]
    
    async def update_portfolio_notes(self, notes: str, user: User) -> None:
        """Update portfolio notes (admin only)"""
        if user.role != "admin":
            raise HTTPException(status_code=403, detail="Admin role required")
        
        # HTML entity encoding for XSS prevention
        sanitized_notes = html.escape(notes) if notes else None
        
        # Update all canvases with new portfolio notes
        await self.db.execute(
            update(Canvas).values(
                portfolio_notes=sanitized_notes,
                updated_at=func.now(),
                updated_by=user.id
            )
        )
        await self.db.commit()
```

## Logic
1. Implement get_summary method with optimized SQL query
2. Apply role-based filtering: GM sees only own VBUs, admin/viewer see all
3. Apply query parameter filters for lane, gm_id, health_status using SQL WHERE clauses
4. Use materialized health_indicator_cache for performance
5. Compute currently_testing from polymorphic relationship
6. Calculate next_review_date from monthly_reviews
7. Implement update_portfolio_notes with admin-only access control
8. Apply HTML entity encoding to prevent XSS attacks
9. Update all canvases with new portfolio notes and audit fields

## Verification
- [ ] Imports resolve without error
- [ ] Type hints complete
- [ ] Tests pass
- [ ] Role-based filtering works correctly
- [ ] Query parameter filters applied properly
- [ ] HTML entity encoding prevents XSS
- [ ] Admin-only access enforced for notes update

## LOC Estimate
~400 lines