# specs/004-monthly-review/tasks/T-014.md

## Task: Review API Routes

## Type
implementation

## Context
- **Phase**: Phase 5 - API Layer
- **Builds on**: T-013 (ReviewService Implementation)
- **Blocks**: T-015 (Review wizard UI)
- **Requirements**: FR-004

## Predecessors

### Cross-Feature
| Feature | File | Task | Import Statement |
|---------|------|------|------------------|
| 001-auth | backend/canvas/auth/dependencies.py | 001-auth/T-015 | `from canvas.auth.dependencies import get_current_user, require_role` |
| 001A-infrastructure | backend/canvas/db.py | 001A-infrastructure/T-007 | `from canvas.db import get_db` |
| 001A-infrastructure | backend/canvas/__init__.py | 001A-infrastructure/T-006 | `from canvas import success_response, list_response` |

### Within Feature
| Task | File | What This Task Imports |
|------|------|------------------------|
| T-013 | backend/canvas/reviews/service.py | ReviewService class |

## Scope
- **CREATE**: `backend/canvas/reviews/router.py`
- **MODIFY**: `backend/canvas/reviews/schemas.py`

## Contract
```python
# router.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID
from typing import List
from canvas.auth.dependencies import get_current_user, require_role
from canvas.db import get_db
from canvas import success_response, list_response
from canvas.reviews.service import ReviewService
from canvas.reviews.schemas import ReviewCreateSchema, ReviewResponse

router = APIRouter(prefix="/api", tags=["reviews"])

@router.get("/canvases/{canvas_id}/reviews", response_model=dict)
async def list_reviews(canvas_id: UUID, current_user=Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    """List reviews for a canvas"""
    ...

@router.post("/canvases/{canvas_id}/reviews", response_model=dict, status_code=201)
async def create_review(canvas_id: UUID, review_data: ReviewCreateSchema, current_user=Depends(require_role("admin", "gm")), db: AsyncSession = Depends(get_db)):
    """Create new review"""
    ...

@router.get("/reviews/{review_id}", response_model=dict)
async def get_review(review_id: UUID, current_user=Depends(get_current_user), db: AsyncSession = Depends(get_db)):
    """Get single review detail"""
    ...

# schemas.py
from pydantic import BaseModel, Field, validator
from typing import List, Optional
from datetime import date, datetime
from uuid import UUID

class CommitmentCreate(BaseModel):
    text: str = Field(..., min_length=1, max_length=1000)
    order: int = Field(..., ge=1, le=3)

class ReviewCreateSchema(BaseModel):
    review_date: date
    what_moved: Optional[str] = Field(None, max_length=5000)
    what_learned: Optional[str] = Field(None, max_length=5000)
    what_threatens: Optional[str] = Field(None, max_length=5000)
    currently_testing_type: str = Field(..., regex="^(thesis|proof_point)$")
    currently_testing_id: UUID
    commitments: List[CommitmentCreate] = Field(..., min_items=1, max_items=3)
    attachment_ids: List[UUID] = Field(default_factory=list, max_items=10)

class CommitmentResponse(BaseModel):
    id: UUID
    text: str
    order: int

class AttachmentResponse(BaseModel):
    id: UUID
    filename: str
    label: Optional[str]
    size_bytes: int

class ReviewResponse(BaseModel):
    id: UUID
    canvas_id: UUID
    review_date: date
    what_moved: Optional[str]
    what_learned: Optional[str]
    what_threatens: Optional[str]
    currently_testing_type: Optional[str]
    currently_testing_id: Optional[UUID]
    created_by: UUID
    created_at: datetime
    commitments: List[CommitmentResponse]
    attachments: List[AttachmentResponse]
    
    class Config:
        from_attributes = True
```

## Logic
1. Create router.py with FastAPI router and authorization dependencies
2. Implement list_reviews endpoint with canvas access verification
3. Implement create_review endpoint with GM/admin authorization
4. Implement get_review endpoint with access control
5. Create schemas.py with Pydantic validation models
6. Add ReviewCreateSchema with field validation and business rules
7. Add response schemas for structured API responses
8. Add Pydantic validators for date and commitment validation

## Verification
- [ ] All endpoints have proper authorization dependencies
- [ ] Request/response schemas have appropriate validation
- [ ] Error handling returns proper HTTP status codes
- [ ] Canvas access verification implemented for GM users
- [ ] Pydantic validators enforce business rules

## LOC Estimate
~150 lines